from telegram import Update, WebAppInfo, InlineKeyboardButton, InlineKeyboardMarkup, LabeledPrice
from telegram.ext import ContextTypes
from datetime import datetime, timedelta
from models import User, MiningMachine, UserCard, Transaction
from keyboards import *
from utils import *
from database import get_db, generate_referral_code
from config import *
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle /start command"""
    user = update.effective_user
    
    # Check for special commands BEFORE doing anything else
    if context.args and context.args[0]:
        arg = context.args[0]
        
        # Check if it's a buy_stars command FIRST
        if arg.startswith('buy_stars_'):
            logger.info(f"Received buy_stars command: {arg}")
            try:
                product_id = int(arg.split('_')[2])
                logger.info(f"Processing buy_stars for product {product_id}")
                await send_stars_invoice(update, context, product_id)
                logger.info(f"send_stars_invoice completed for product {product_id}")
                return  # Don't show main menu, just send invoice
            except (ValueError, IndexError) as e:
                logger.error(f"Invalid buy_stars parameter: {arg}, error: {e}")
    
    # If we got here, it's a normal /start command
    logger.info(f"Processing normal /start for user {user.id}")
    
    with get_db() as db:
        # Check if user exists
        db_user = db.query(User).filter_by(telegram_id=user.id).first()
        
        if not db_user:
            # Create new user
            db_user = User(
                telegram_id=user.id,
                username=user.username,
                referral_code=generate_referral_code(),
            )
            db.add(db_user)
            db.flush()  # Get the ID
            
            # Check for referral
            if context.args and context.args[0]:
                arg = context.args[0]
                
                # Check for referral - use telegram_id as referral code
                referral_value = arg
                referrer = None
                
                # First try to find by telegram_id (most common case)
                try:
                    referral_telegram_id = int(referral_value)
                    referrer = db.query(User).filter_by(telegram_id=referral_telegram_id).first()
                    print(f"Looking for referrer by telegram_id: {referral_telegram_id}, found: {referrer is not None}")
                except ValueError:
                    # Try by referral_code if it's not a number
                    referrer = db.query(User).filter_by(referral_code=referral_value).first()
                    print(f"Looking for referrer by code: {referral_value}, found: {referrer is not None}")
                
                if referrer and referrer.id != db_user.id:
                    db_user.referred_by = referrer.id
                    referrer.referrals_count += 1
                    db_user.coins += REFERRAL_BONUS
                    referrer.coins += REFERRAL_BONUS // 2
                    logger.info(f"User {db_user.telegram_id} was referred by {referrer.telegram_id}")
        
        # Calculate offline income
        offline_income = calculate_offline_income(db_user)
        if offline_income > 0:
            db_user.coins += offline_income
            db_user.total_earned += offline_income
            try:
                transaction = Transaction(
                    user_id=db_user.id,
                    transaction_type="offline_income",
                    amount=offline_income,
                    currency="coins"
                )
                db.add(transaction)
            except Exception as e:
                logger.warning(f"Could not create transaction: {e}")
        
        db_user.last_active = datetime.utcnow()
    
    message = """<b>Quantum Nexus</b>
    
–ö—Ä–∏–ø—Ç–æ-—Ç–∞–ø–∞–ª–∫–∞ –Ω–æ–≤–æ–≥–æ –ø–æ–∫–æ–ª–µ–Ω–∏—è —Å —É–Ω–∏–∫–∞–ª—å–Ω—ã–º–∏ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—è–º–∏ –º–∞–π–Ω–∏–Ω–≥–∞ –∏ –ø–∞—Å—Å–∏–≤–Ω–æ–≥–æ –¥–æ—Ö–æ–¥–∞.

üî• <b>–í–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏:</b>
‚Ä¢ –°–∏—Å—Ç–µ–º–∞ —Ç–∞–ø–∞ —Å —ç–Ω–µ—Ä–≥–∏–µ–π
‚Ä¢ –ú–∞–π–Ω–∏–Ω–≥ QuanHash (–æ–±–º–µ–Ω–∏–≤–∞–µ—Ç—Å—è –Ω–∞ USDT)
‚Ä¢ –ü–∞—Å—Å–∏–≤–Ω—ã–π –¥–æ—Ö–æ–¥ –æ—Ç –∫–∞—Ä—Ç–æ—á–µ–∫
‚Ä¢ –†–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞
‚Ä¢ –ú–∞–≥–∞–∑–∏–Ω –±—É—Å—Ç–æ–≤ –∏ —É–ª—É—á—à–µ–Ω–∏–π
‚Ä¢ –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –≤—ã–≤–æ–¥–∞ —Å—Ä–µ–¥—Å—Ç–≤

üíé <b>–ß—Ç–æ –≤–∞—Å –∂–¥–µ—Ç:</b>
–†–∞–∑–≤–∏–≤–∞–π—Ç–µ —Å–≤–æ—é –∫—Ä–∏–ø—Ç–æ-–∏–º–ø–µ—Ä–∏—é, –ø–æ–∫—É–ø–∞–π—Ç–µ –º–∞–π–Ω–∏–Ω–≥-–º–∞—à–∏–Ω—ã, —Å–æ–±–∏—Ä–∞–π—Ç–µ –∫–∞—Ä—Ç–æ—á–∫–∏ –¥–ª—è –ø–∞—Å—Å–∏–≤–Ω–æ–≥–æ –¥–æ—Ö–æ–¥–∞ –∏ —Ä–∞–∑–≤–∏–≤–∞–π—Ç–µ—Å—å —Å –¥—Ä—É–∑—å—è–º–∏!

üöÄ <b>–ù–∞—á–Ω–∏—Ç–µ –ø—Ä—è–º–æ —Å–µ–π—á–∞—Å!</b>

–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:"""
    
    keyboard = [
        [
            InlineKeyboardButton("üéÆ –û—Ç–∫—Ä—ã—Ç—å –∏–≥—Ä—É", web_app=WebAppInfo(url="https://quantum-nexus.ru/web_app.html?v=3.0"))
        ]
    ]
    
    await update.message.reply_text(
        message,
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode='HTML'
    )


async def button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle button callbacks"""
    query = update.callback_query
    await query.answer()
    
    user_id = query.from_user.id
    db = next(get_db())
    db_user = db.query(User).filter_by(telegram_id=user_id).first()
    
    if not db_user:
        return
    
    data = query.data
    
    if data == "main_menu":
        await show_main_menu(query, db_user)
    elif data == "tap":
        await handle_tap(query, db_user, db)
    elif data == "energy_status":
        await show_energy_status(query, db_user)
    elif data == "mining":
        await show_mining(query, db_user, db)
    elif data == "cards":
        await show_user_cards(query, db_user, db)
    elif data == "shop":
        await show_shop(query, db_user)
    elif data == "stats":
        await show_stats(query, db_user)
    elif data == "rating":
        await show_rating(query, db_user, db)
    elif data == "referrals":
        await show_referrals(query, db_user, db)
    elif data.startswith("shop_"):
        await handle_shop(query, data, db_user, db)
    elif data.startswith("buy_"):
        await handle_purchase(query, data, db_user, db)
    elif data.startswith("machine_"):
        await handle_machine(query, data, db_user, db)
    elif data.startswith("card_"):
        await handle_card(query, data, db_user, db)


async def show_main_menu(query, user):
    """Show main menu"""
    message = f"""
üè† <b>–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é</b>

üí∞ –ö–æ–∏–Ω—ã: {format_currency(user.coins)} ü™ô
üíé QuanHash: {format_currency(user.quanhash)} ‚ö°
‚ö° –≠–Ω–µ—Ä–≥–∏—è: {user.energy}/{user.max_energy}

–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:
    """
    
    await query.edit_message_text(
        message,
        reply_markup=get_main_menu(),
        parse_mode='HTML'
    )


async def handle_tap(query, user, db):
    """Handle tap action"""
    current_time = datetime.utcnow().timestamp()
    
    # Anti-cheat check
    if not check_anti_cheat(user.id, current_time):
        await query.answer("‚ö†Ô∏è –°–ª–∏—à–∫–æ–º –±—ã—Å—Ç—Ä–æ! –ü–æ–¥–æ–∂–¥–∏—Ç–µ –Ω–µ–º–Ω–æ–≥–æ.", show_alert=True)
        return
    
    # Check energy
    if user.energy < ENERGY_COST_PER_TAP:
        await query.answer("‚ö†Ô∏è –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —ç–Ω–µ—Ä–≥–∏–∏!", show_alert=True)
        return
    
    # Calculate reward
    reward = BASE_TAP_REWARD * user.active_multiplier
    
    # Update user
    user.coins += reward
    user.energy -= ENERGY_COST_PER_TAP
    user.total_taps += 1
    user.total_earned += reward
    user.last_active = datetime.utcnow()
    
    # Update multiplier if expired
    if user.multiplier_expires_at and datetime.utcnow() > user.multiplier_expires_at:
        user.active_multiplier = 1.0
        user.multiplier_expires_at = None
    
    db.commit()
    
    # Create transaction
    transaction = Transaction(
        user_id=user.id,
        transaction_type="tap",
        amount=reward,
        currency="coins"
    )
    db.add(transaction)
    db.commit()
    
    await query.answer(f"üí∞ +{format_currency(reward)} ü™ô")


async def show_energy_status(query, user):
    """Show energy status"""
    # Regenerate energy over time
    time_since_update = (datetime.utcnow() - user.updated_at).total_seconds() / 60
    energy_to_add = int(time_since_update * ENERGY_REGEN_PER_MINUTE)
    
    if energy_to_add > 0:
        user.energy = min(user.energy + energy_to_add, user.max_energy)
        db = next(get_db())
        db_user = db.query(User).filter_by(id=user.id).first()
        db_user.energy = user.energy
        db_user.updated_at = datetime.utcnow()
        db.commit()
    
    message = f"""
‚ö° <b>–≠–Ω–µ—Ä–≥–∏—è</b>

‚ö° –¢–µ–∫—É—â–∞—è —ç–Ω–µ—Ä–≥–∏—è: {user.energy}/{user.max_energy}

‚ö° –≠–Ω–µ—Ä–≥–∏—è –≤–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç—Å—è: {ENERGY_REGEN_PER_MINUTE} –µ–¥/–º–∏–Ω
‚è±Ô∏è –î–æ –ø–æ–ª–Ω–æ–π –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è: {int((user.max_energy - user.energy) / ENERGY_REGEN_PER_MINUTE)} –º–∏–Ω

–í—ã –º–æ–∂–µ—Ç–µ –∫—É–ø–∏—Ç—å –±–æ–ª—å—à–µ —ç–Ω–µ—Ä–≥–∏–∏ –≤ –º–∞–≥–∞–∑–∏–Ω–µ!
    """
    
    await query.edit_message_text(
        message,
        reply_markup=get_back_button(),
        parse_mode='HTML'
    )


async def show_mining(query, user, db):
    """Show mining menu"""
    machines = db.query(MiningMachine).filter_by(user_id=user.id).all()
    
    if not machines:
        message = f"""
üè≠ <b>–ú–∞–π–Ω–∏–Ω–≥</b>

–£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç –∫—Ä–∏–ø—Ç–æ–º–∞—à–∏–Ω! –ö—É–ø–∏—Ç–µ –ø–µ—Ä–≤—É—é –≤ –º–∞–≥–∞–∑–∏–Ω–µ.
        """
    else:
        message = f"""
üè≠ <b>–ú–∞–π–Ω–∏–Ω–≥</b>

üí∞ –ö–æ–∏–Ω—ã: {format_currency(user.coins)} ü™ô
üíé QuanHash: {format_currency(user.quanhash)} ‚ö°

üëÄ –í—ã–±–µ—Ä–∏—Ç–µ –º–∞—à–∏–Ω—É –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è:
        """
    
    await query.edit_message_text(
        message,
        reply_markup=get_mining_menu(db, user),
        parse_mode='HTML'
    )


async def show_user_cards(query, user, db):
    """Show user cards"""
    cards = db.query(UserCard).filter_by(user_id=user.id).all()
    
    if not cards:
        message = f"""
üí≥ <b>–ö–∞—Ä—Ç–æ—á–∫–∏</b>

–£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç –∫–∞—Ä—Ç–æ—á–µ–∫! –ö—É–ø–∏—Ç–µ –ø–µ—Ä–≤—É—é –≤ –º–∞–≥–∞–∑–∏–Ω–µ.
        """
    else:
        total_income = sum(card.income_per_minute for card in cards if card.is_active)
        message = f"""
üí≥ <b>–ö–∞—Ä—Ç–æ—á–∫–∏</b>

üìä –í—Å–µ–≥–æ –∫–∞—Ä—Ç–æ—á–µ–∫: {len(cards)}
üí∞ –ü–∞—Å—Å–∏–≤–Ω—ã–π –¥–æ—Ö–æ–¥: {format_currency(total_income)} ü™ô/–º–∏–Ω

üëÄ –í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ä—Ç–æ—á–∫—É:
        """
    
    await query.edit_message_text(
        message,
        reply_markup=get_user_cards_menu(db, user),
        parse_mode='HTML'
    )


async def show_shop(query, user):
    """Show shop menu"""
    message = f"""
üõí <b>–ú–∞–≥–∞–∑–∏–Ω</b>

üí∞ –ö–æ–∏–Ω—ã: {format_currency(user.coins)} ü™ô
üíé QuanHash: {format_currency(user.quanhash)} ‚ö°

–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é:
    """
    
    await query.edit_message_text(
        message,
        reply_markup=get_shop_menu(),
        parse_mode='HTML'
    )


async def show_stats(query, user):
    """Show user statistics"""
    rank_coins = get_user_rank(next(get_db()), user, "coins")
    rank_hash = get_user_rank(next(get_db()), user, "quanhash")
    
    message = f"""
üìä <b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞</b>

üë§ <b>–ü—Ä–æ—Ñ–∏–ª—å:</b>
üí∞ –ö–æ–∏–Ω—ã: {format_currency(user.coins)} ü™ô
üíé QuanHash: {format_currency(user.quanhash)} ‚ö°
‚ö° –≠–Ω–µ—Ä–≥–∏—è: {user.energy}/{user.max_energy}

üìà <b>–î–æ—Å—Ç–∏–∂–µ–Ω–∏—è:</b>
üëÜ –í—Å–µ–≥–æ —Ç–∞–ø–æ–≤: {user.total_taps}
üíµ –ó–∞—Ä–∞–±–æ—Ç–∞–Ω–æ: {format_currency(user.total_earned)} ü™ô
‚õèÔ∏è –î–æ–±—ã—Ç–æ QuanHash: {format_currency(user.total_mined)} ‚ö°

üèÜ <b>–†–µ–π—Ç–∏–Ω–≥:</b>
ü™ô –ü–æ –∫–æ–∏–Ω–∞–º: #{rank_coins}
‚ö° –ü–æ QuanHash: #{rank_hash}

üë• <b>–†–µ—Ñ–µ—Ä–∞–ª—ã:</b>
üìä –í—Å–µ–≥–æ —Ä–µ—Ñ–µ—Ä–∞–ª–æ–≤: {user.referrals_count}
üí∞ –î–æ—Ö–æ–¥ —Å —Ä–µ—Ñ–µ—Ä–∞–ª–æ–≤: {format_currency(user.referral_income)} ü™ô
    """
    
    await query.edit_message_text(
        message,
        reply_markup=get_back_button(),
        parse_mode='HTML'
    )


async def show_rating(query, user, db):
    """Show rating/leaderboard"""
    top_coins = get_top_users(db, "coins", 10)
    top_hash = get_top_users(db, "quanhash", 10)
    
    message = "<b>üèÜ –†–µ–π—Ç–∏–Ω–≥ –∏–≥—Ä–æ–∫–æ–≤</b>\n\n"
    message += "<b>üí∞ –¢–æ–ø –ø–æ –∫–æ–∏–Ω–∞–º:</b>\n"
    
    for i, top_user in enumerate(top_coins, 1):
        message += f"{i}. {top_user.username or '–ò–≥—Ä–æ–∫'} - {format_currency(top_user.total_earned)} ü™ô\n"
    
    message += "\n<b>‚ö° –¢–æ–ø –ø–æ QuanHash:</b>\n"
    
    for i, top_user in enumerate(top_hash, 1):
        message += f"{i}. {top_user.username or '–ò–≥—Ä–æ–∫'} - {format_currency(top_user.total_mined)} ‚ö°\n"
    
    await query.edit_message_text(
        message,
        reply_markup=get_back_button(),
        parse_mode='HTML'
    )


async def show_referrals(query, user, db):
    """Show referral information"""
    message = f"""
üë• <b>–†–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞</b>

üÜî –í–∞—à —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω—ã–π –∫–æ–¥:
<code>{user.referral_code}</code>

üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:
üë• –í—Å–µ–≥–æ —Ä–µ—Ñ–µ—Ä–∞–ª–æ–≤: {user.referrals_count}
üí∞ –î–æ—Ö–æ–¥ —Å —Ä–µ—Ñ–µ—Ä–∞–ª–æ–≤: {format_currency(user.referral_income)} ü™ô

üîó –í–∞—à–∞ —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞—è —Å—Å—ã–ª–∫–∞:
<code>https://t.me/{context.bot.username}?start={user.referral_code}</code>

üí° –ó–∞ –∫–∞–∂–¥–æ–≥–æ –Ω–æ–≤–æ–≥–æ —Ä–µ—Ñ–µ—Ä–∞–ª–∞ –≤—ã –ø–æ–ª—É—á–∞–µ—Ç–µ –±–æ–Ω—É—Å—ã!
    """
    
    await query.edit_message_text(
        message,
        reply_markup=get_back_button(),
        parse_mode='HTML'
    )


async def handle_shop(query, data, user, db):
    """Handle shop submenu"""
    if data == "shop_boosts":
        await query.edit_message_reply_markup(get_boosts_menu())
    elif data == "shop_machines":
        await query.edit_message_reply_markup(get_machines_menu())
    elif data == "shop_cards":
        await query.edit_message_reply_markup(get_cards_menu())
    elif data == "shop_energy":
        await query.edit_message_text(
            "‚ö° –ö—É–ø–∏—Ç—å 50 —ç–Ω–µ—Ä–≥–∏–∏ –∑–∞ 1000 ü™ô",
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("–ö—É–ø–∏—Ç—å", callback_data="buy_energy_50")
            ], [InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="shop")]])
        )


async def handle_purchase(query, data, user, db):
    """Handle purchases"""
    if data == "buy_energy_50":
        price = 1000
        if user.coins >= price:
            user.coins -= price
            user.energy = min(user.energy + 50, user.max_energy)
            db.commit()
            await query.answer("‚úÖ –≠–Ω–µ—Ä–≥–∏—è –∫—É–ø–ª–µ–Ω–∞!")
        else:
            await query.answer("‚ö†Ô∏è –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∫–æ–∏–Ω–æ–≤!", show_alert=True)
    
    # Handle other purchases similarly...


async def pre_checkout_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle pre-checkout query for Stars payment validation"""
    query = update.pre_checkout_query
    
    user_id = query.from_user.id
    
    with get_db() as db:
        user = db.query(User).filter_by(telegram_id=user_id).first()
        
        if not user:
            await query.answer(ok=False, error_message="–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω")
            return
        
        # Validate payload
        invoice_payload = query.invoice_payload
        
        if not invoice_payload.startswith("stars_"):
            await query.answer(ok=False, error_message="–ù–µ–≤–µ—Ä–Ω—ã–π invoice")
            return
        
        # Approve the checkout
        await query.answer(ok=True)


async def successful_payment_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle successful Stars payment - only called when payment is REAL"""
    payment = update.message.successful_payment
    user_id = update.effective_user.id
    
    # Log the payment details
    logger.info(f"Payment received: {payment}")
    logger.info(f"Payment invoice: {payment.invoice_payload}")
    logger.info(f"Payment total amount: {payment.total_amount}")
    logger.info(f"Payment currency: {payment.currency}")
    
    # Parse payload: stars_{user_id}_{product_id}
    invoice_payload = payment.invoice_payload
    
    # Verify this is a Stars payment
    if payment.currency != "XTR":
        logger.error(f"Wrong currency: {payment.currency}, expected XTR")
        await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω–∞—è –≤–∞–ª—é—Ç–∞")
        return
    
    try:
        parts = invoice_payload.split("_")
        if len(parts) != 3 or parts[0] != "stars":
            logger.error(f"Invalid payload format: {invoice_payload}")
            await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π payload")
            return
        
        user_db_id = int(parts[1])
        product_id = int(parts[2])
        
        # Define product amounts - 60 items
        product_coins = {
            1: 200000, 2: 500000, 3: 800000, 4: 1000000, 5: 1500000, 6: 2000000, 7: 2500000, 8: 3000000, 9: 3500000, 10: 4000000,
            11: 1500000, 12: 3000000, 13: 4500000, 14: 6000000, 15: 7500000, 16: 9000000, 17: 10500000, 18: 12000000, 19: 13500000, 20: 15000000,
            21: 5000000, 22: 8000000, 23: 12000000, 24: 16000000, 25: 20000000, 26: 25000000, 27: 30000000, 28: 35000000, 29: 40000000, 30: 45000000,
            31: 12000000, 32: 15000000, 33: 18000000, 34: 21000000, 35: 24000000, 36: 27000000, 37: 30000000, 38: 33000000, 39: 36000000, 40: 40000000,
            41: 25000000, 42: 35000000, 43: 45000000, 44: 55000000, 45: 65000000, 46: 75000000, 47: 85000000, 48: 95000000, 49: 105000000, 50: 120000000,
            51: 50000000, 52: 100000000, 53: 150000000, 54: 200000000, 55: 250000000, 56: 300000000, 57: 350000000, 58: 400000000, 59: 450000000, 60: 500000000
        }
        
        coins_to_add = product_coins.get(product_id, 0)
        
        if coins_to_add == 0:
            logger.error(f"Unknown product: {product_id}")
            await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞: –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–æ–≤–∞—Ä")
            return
        
        with get_db() as db:
            user = db.query(User).filter_by(id=user_db_id, telegram_id=user_id).first()
            
            if not user:
                logger.error(f"User not found: {user_db_id}/{user_id}")
                await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞: –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω")
                return
            
            # Add coins
            user.coins += coins_to_add
            db.commit()
            
            # Log successful payment
            logger.info(f"‚úÖ Stars payment successful! User {user_id} bought product {product_id} for {coins_to_add} coins")
            
            await update.message.reply_text(
                f"‚ú® –ü–æ–∫—É–ø–∫–∞ —É—Å–ø–µ—à–Ω–∞!\n\n"
                f"üíé –û–ø–ª–∞—á–µ–Ω–æ: {payment.total_amount} ‚≠ê\n"
                f"üí∞ –ü–æ–ª—É—á–µ–Ω–æ: {coins_to_add:,} –∫–æ–∏–Ω–æ–≤\n\n"
                f"üìä –ù–æ–≤—ã–π –±–∞–ª–∞–Ω—Å: {user.coins:,} –∫–æ–∏–Ω–æ–≤"
            )
            
    except Exception as e:
        logger.error(f"Error processing payment: {e}", exc_info=True)
        await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –ø–ª–∞—Ç–µ–∂–∞")


async def send_stars_invoice(update: Update, context: ContextTypes.DEFAULT_TYPE, product_id: int):
    """Send Stars invoice with real Telegram Stars payment"""
    
    logger.info(f"=== send_stars_invoice called with product_id={product_id} ===")
    
    # Define products with Stars prices - 60 items
    products = {
        # STARTING (1-10)
        1: {'title': 'üí´ –ü–µ—Ä–≤—ã–µ —à–∞–≥–∏', 'description': '200,000 –∫–æ–∏–Ω–æ–≤', 'stars': 50, 'coins': 200000},
        2: {'title': '‚ú® –ë–∞–∑–æ–≤—ã–π', 'description': '500,000 –∫–æ–∏–Ω–æ–≤', 'stars': 120, 'coins': 500000},
        3: {'title': 'üåü –ù–∞—á–∞–ª–æ –ø—É—Ç–∏', 'description': '800,000 –∫–æ–∏–Ω–æ–≤', 'stars': 180, 'coins': 800000},
        4: {'title': 'üíé –ü—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω—ã–π', 'description': '1,000,000 –∫–æ–∏–Ω–æ–≤', 'stars': 240, 'coins': 1000000},
        5: {'title': 'üéÅ –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å', 'description': '1,500,000 –∫–æ–∏–Ω–æ–≤', 'stars': 320, 'coins': 1500000},
        6: {'title': 'üí∞ –°—Ç–∞—Ä—Ç–æ–≤—ã–π', 'description': '2,000,000 –∫–æ–∏–Ω–æ–≤', 'stars': 400, 'coins': 2000000},
        7: {'title': '‚ö° –ë—ã—Å—Ç—Ä—ã–π —Å—Ç–∞—Ä—Ç', 'description': '2,500,000 –∫–æ–∏–Ω–æ–≤', 'stars': 480, 'coins': 2500000},
        8: {'title': 'üéØ –ü–µ—Ä–≤—ã–π —à–∞–≥', 'description': '3,000,000 –∫–æ–∏–Ω–æ–≤', 'stars': 560, 'coins': 3000000},
        9: {'title': 'üåà –†–∞–¥—É–≥–∞', 'description': '3,500,000 –∫–æ–∏–Ω–æ–≤', 'stars': 640, 'coins': 3500000},
        10: {'title': 'üí´ –í–æ–ª—à–µ–±–Ω—ã–π', 'description': '4,000,000 –∫–æ–∏–Ω–æ–≤', 'stars': 720, 'coins': 4000000},
        # PREMIUM (11-20)
        11: {'title': '‚ö° –°–≤–µ—Ç–æ–≤–æ–π', 'description': '1,500,000 –∫–æ–∏–Ω–æ–≤', 'stars': 300, 'coins': 1500000},
        12: {'title': 'üéØ –ü—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª', 'description': '3,000,000 –∫–æ–∏–Ω–æ–≤', 'stars': 600, 'coins': 3000000},
        13: {'title': 'üöÄ –ú–æ—â—å', 'description': '4,500,000 –∫–æ–∏–Ω–æ–≤', 'stars': 900, 'coins': 4500000},
        14: {'title': 'üíé –ê–ª–º–∞–∑–Ω—ã–π', 'description': '6,000,000 –∫–æ–∏–Ω–æ–≤', 'stars': 1200, 'coins': 6000000},
        15: {'title': 'üî• –û–≥–Ω–µ–Ω–Ω—ã–π', 'description': '7,500,000 –∫–æ–∏–Ω–æ–≤', 'stars': 1500, 'coins': 7500000},
        16: {'title': '‚ö° –≠–ª–µ–∫—Ç—Ä–æ–Ω–Ω—ã–π', 'description': '9,000,000 –∫–æ–∏–Ω–æ–≤', 'stars': 1800, 'coins': 9000000},
        17: {'title': 'üåü –ó–≤—ë–∑–¥–Ω—ã–π', 'description': '10,500,000 –∫–æ–∏–Ω–æ–≤', 'stars': 2100, 'coins': 10500000},
        18: {'title': 'üí´ –ö–æ—Å–º–∏—á–µ—Å–∫–∏–π', 'description': '12,000,000 –∫–æ–∏–Ω–æ–≤', 'stars': 2400, 'coins': 12000000},
        19: {'title': 'üéÅ –ü–æ–¥–∞—Ä–æ—á–Ω—ã–π VIP', 'description': '13,500,000 –∫–æ–∏–Ω–æ–≤', 'stars': 2700, 'coins': 13500000},
        20: {'title': 'üîÆ –ú–∞–≥–∏—á–µ—Å–∫–∏–π', 'description': '15,000,000 –∫–æ–∏–Ω–æ–≤', 'stars': 3000, 'coins': 15000000},
        # VIP ‚Üí PREMIUM FUNCTIONS (21-30)
        21: {'title': 'üíé VIP —Å—Ç–∞—Ä—Ç–æ–≤—ã–π', 'description': '5M –∫–æ–∏–Ω–æ–≤ –¥–ª—è –Ω–∞—á–∞–ª–∞', 'stars': 1000, 'coins': 5000000},
        22: {'title': 'üöÄ VIP —É—Å–∫–æ—Ä–µ–Ω–∏–µ', 'description': '8M –∫–æ–∏–Ω–æ–≤ + –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç', 'stars': 1600, 'coins': 8000000},
        23: {'title': 'üëë VIP —Å—Ç–∞—Ç—É—Å', 'description': '12M –∫–æ–∏–Ω–æ–≤ + –±–æ–Ω—É—Å', 'stars': 2400, 'coins': 12000000},
        24: {'title': '‚ö° VIP —Ç—É—Ä–±–æ', 'description': '16M –∫–æ–∏–Ω–æ–≤ + —ç–∫—Å–∫–ª—é–∑–∏–≤', 'stars': 3200, 'coins': 16000000},
        25: {'title': 'üíé VIP –∫–æ—Ä–æ–ª–µ–≤—Å—Ç–≤–æ', 'description': '20M –∫–æ–∏–Ω–æ–≤ + –≤—Å–µ –±–æ–Ω—É—Å—ã', 'stars': 4000, 'coins': 20000000},
        26: {'title': 'üîì VIP –±–µ–∑–ª–∏–º–∏—Ç', 'description': '25M –∫–æ–∏–Ω–æ–≤ + –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π –±–æ–Ω—É—Å', 'stars': 5000, 'coins': 25000000},
        27: {'title': 'üèÜ VIP —á–µ–º–ø–∏–æ–Ω', 'description': '30M –∫–æ–∏–Ω–æ–≤ + —Ç–æ–ø-–±–æ–Ω—É—Å', 'stars': 6000, 'coins': 30000000},
        28: {'title': 'üåü VIP –ª–µ–≥–µ–Ω–¥–∞', 'description': '35M –∫–æ–∏–Ω–æ–≤ + –ª–µ–≥–µ–Ω–¥–∞—Ä–Ω—ã–π –±–æ–Ω—É—Å', 'stars': 7000, 'coins': 35000000},
        29: {'title': 'üíé VIP –∞–ª–º–∞–∑', 'description': '40M –∫–æ–∏–Ω–æ–≤ + –≤—Å–µ VIP –±–æ–Ω—É—Å—ã', 'stars': 8000, 'coins': 40000000},
        30: {'title': 'üëë VIP –∏–º–ø–µ—Ä–∞—Ç–æ—Ä', 'description': '45M –∫–æ–∏–Ω–æ–≤ + –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–µ –ø—Ä–µ–º–∏—É–º –±–æ–Ω—É—Å—ã', 'stars': 9000, 'coins': 45000000},
        # LIMITED ‚Üí QUANHASH PACKS (31-40)
        31: {'title': 'üîÆ Starter Hash', 'description': '1,000 QuanHash', 'stars': 2500, 'coins': 12000000},
        32: {'title': 'üíé Basic Hash', 'description': '5,000 QuanHash', 'stars': 3200, 'coins': 15000000},
        33: {'title': '‚ö° Power Hash', 'description': '10,000 QuanHash', 'stars': 3900, 'coins': 18000000},
        34: {'title': 'üî• Fire Hash', 'description': '15,000 QuanHash', 'stars': 4600, 'coins': 21000000},
        35: {'title': 'üí• Blast Hash', 'description': '25,000 QuanHash', 'stars': 5300, 'coins': 24000000},
        36: {'title': 'üåü Stellar Hash', 'description': '50,000 QuanHash', 'stars': 6000, 'coins': 27000000},
        37: {'title': 'üíé Diamond Hash', 'description': '100,000 QuanHash', 'stars': 6700, 'coins': 30000000},
        38: {'title': 'üöÄ Rocket Hash', 'description': '250,000 QuanHash', 'stars': 7400, 'coins': 33000000},
        39: {'title': 'üëë Crown Hash', 'description': '500,000 QuanHash', 'stars': 8100, 'coins': 36000000},
        40: {'title': 'üí´ Ultimate Hash', 'description': '1,000,000 QuanHash', 'stars': 9000, 'coins': 40000000},
        # ULTRA ‚Üí COMBO SETS (41-50)
        41: {'title': 'üéÅ –°—Ç–∞—Ä—Ç–æ–≤—ã–π –º–µ–≥–∞—Å–µ—Ç', 'description': '10 –∫–∞—Ä—Ç–æ—á–µ–∫ + 1M –∫–æ–∏–Ω–æ–≤', 'stars': 5000, 'coins': 25000000},
        42: {'title': 'üî• –ì–æ—Ä—è—á–∏–π –∫–æ–º–±–æ', 'description': '20 –∫–∞—Ä—Ç–æ—á–µ–∫ + 10M –∫–æ–∏–Ω–æ–≤', 'stars': 7000, 'coins': 35000000},
        43: {'title': 'üíé –≠–ª–∏—Ç–Ω—ã–π –Ω–∞–±–æ—Ä', 'description': '50 –∫–∞—Ä—Ç–æ—á–µ–∫ + 50M –∫–æ–∏–Ω–æ–≤', 'stars': 9000, 'coins': 45000000},
        44: {'title': 'üöÄ –ú–µ–≥–∞ —Å–≤—è–∑–∫–∞', 'description': '100 –∫–∞—Ä—Ç–æ—á–µ–∫ + 100M –∫–æ–∏–Ω–æ–≤', 'stars': 11000, 'coins': 55000000},
        45: {'title': 'üåü –õ–µ–≥–µ–Ω–¥–∞—Ä–Ω—ã–π –º–µ–≥–∞—Å–µ—Ç', 'description': '200 –∫–∞—Ä—Ç–æ—á–µ–∫ + 200M', 'stars': 13000, 'coins': 65000000},
        46: {'title': 'üíé –ë—Ä–∏–ª–ª–∏–∞–Ω—Ç–æ–≤–∞—è —Å–≤—è–∑–∫–∞', 'description': 'VIP –∫–∞—Ä—Ç—ã + –±–µ–∑–ª–∏–º–∏—Ç', 'stars': 15000, 'coins': 75000000},
        47: {'title': 'üëë –ö–æ—Ä–æ–ª–µ–≤—Å–∫–∏–π –∫–æ–º–±–æ', 'description': '300 –∫–∞—Ä—Ç + VIP –¥–æ—Å—Ç—É–ø', 'stars': 17000, 'coins': 85000000},
        48: {'title': 'üî• –û–≥–Ω–µ–Ω–Ω—ã–π –º–µ–≥–∞—Å–µ—Ç', 'description': '500 –∫–∞—Ä—Ç + 500M', 'stars': 19000, 'coins': 95000000},
        49: {'title': 'üí´ –ö–æ—Å–º–∏—á–µ—Å–∫–∏–π –∫–æ–º–±–æ', 'description': '1000 –∫–∞—Ä—Ç + –≤—Å—ë VIP', 'stars': 21000, 'coins': 105000000},
        50: {'title': 'üéØ –ê–ë–°–û–õ–Æ–¢ –í–°–Å', 'description': '–í–°–Å —á—Ç–æ –µ—Å—Ç—å –≤ –∏–≥—Ä–µ!', 'stars': 24000, 'coins': 120000000},
        # MEGA (51-60)
        51: {'title': 'üöÄ –ö–æ—Å–º–æ—Å', 'description': '50,000,000 –∫–æ–∏–Ω–æ–≤', 'stars': 10000, 'coins': 50000000},
        52: {'title': '‚≠ê –í—Å–µ–ª–µ–Ω–Ω–∞—è', 'description': '100,000,000 –∫–æ–∏–Ω–æ–≤', 'stars': 20000, 'coins': 100000000},
        53: {'title': 'üåå –ì–∞–ª–∞–∫—Ç–∏–∫–∞', 'description': '150,000,000 –∫–æ–∏–Ω–æ–≤', 'stars': 30000, 'coins': 150000000},
        54: {'title': 'üåü –°–æ–∑–≤–µ–∑–¥–∏–µ', 'description': '200,000,000 –∫–æ–∏–Ω–æ–≤', 'stars': 40000, 'coins': 200000000},
        55: {'title': 'üí´ –¢—É–º–∞–Ω–Ω–æ—Å—Ç—å', 'description': '250,000,000 –∫–æ–∏–Ω–æ–≤', 'stars': 50000, 'coins': 250000000},
        56: {'title': 'üöÄ –í–∏—Ö—Ä—å', 'description': '300,000,000 –∫–æ–∏–Ω–æ–≤', 'stars': 60000, 'coins': 300000000},
        57: {'title': '‚≠ê –ü—É–ª—å—Å–∞—Ä', 'description': '350,000,000 –∫–æ–∏–Ω–æ–≤', 'stars': 70000, 'coins': 350000000},
        58: {'title': 'üåå –ö–≤–∞–∑–∞—Ä', 'description': '400,000,000 –∫–æ–∏–Ω–æ–≤', 'stars': 80000, 'coins': 400000000},
        59: {'title': 'üåü –ß—ë—Ä–Ω–∞—è –¥—ã—Ä–∞', 'description': '450,000,000 –∫–æ–∏–Ω–æ–≤', 'stars': 90000, 'coins': 450000000},
        60: {'title': '‚≠ê –ë–æ–ª—å—à–æ–π –≤–∑—Ä—ã–≤', 'description': '500,000,000 –∫–æ–∏–Ω–æ–≤', 'stars': 100000, 'coins': 500000000}
    }
    
    product = products.get(product_id)
    if not product:
        logger.error(f"Invalid product_id: {product_id}")
        await update.message.reply_text("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ç–æ–≤–∞—Ä")
        return
    
    logger.info(f"Product found: {product}")
    
    user_id = update.effective_user.id
    logger.info(f"User ID: {user_id}")
    
    with get_db() as db:
        user = db.query(User).filter_by(telegram_id=user_id).first()
        
        if not user:
            logger.error(f"User {user_id} not found in database")
            await update.message.reply_text("‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω")
            return
        
        logger.info(f"User found: {user.username}, DB ID: {user.id}")
        
        try:
            # Send invoice with Telegram Stars
            prices = [LabeledPrice(
                label=f"{product['title']} - {product['description']}",
                amount=product['stars']
            )]
            
            logger.info(f"Creating invoice with title: {product['title']}")
            logger.info(f"Stars amount: {product['stars']}")
            logger.info(f"Chat ID: {update.effective_chat.id}")
            
            # For Telegram Stars, set provider_token to None
            invoice_result = await context.bot.send_invoice(
                chat_id=update.effective_chat.id,
                title=f"üíé {product['title']}",
                description=product['description'],
                payload=f"stars_{user.id}_{product_id}",
                provider_token=None,  # None for Stars (not empty string!)
                currency="XTR",
                prices=prices,
                start_parameter=f"buy_stars_{product_id}"  # Add start parameter
            )
            
            logger.info(f"‚úÖ Invoice sent successfully! Message ID: {invoice_result.message_id}")
            # Invoice is displayed by Telegram automatically, no extra message needed
            return  # Exit function without sending extra message
            
        except Exception as e:
            logger.error(f"‚ùå Failed to send Stars invoice: {e}", exc_info=True)
            
            # If Stars are not available, show alternative
            await update.message.reply_text(
                f"‚ùå –û—à–∏–±–∫–∞: {str(e)}\n\n"
                f"üí° Telegram Stars –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã –≤ –≤–∞—à–µ–º —Ä–µ–≥–∏–æ–Ω–µ.\n\n"
                f"üì¶ Telegram Stars —Ä–∞–±–æ—Ç–∞—é—Ç —Ç–æ–ª—å–∫–æ –≤:\n"
                f"   ‚Ä¢ –°–®–ê\n"
                f"   ‚Ä¢ –Ø–ø–æ–Ω–∏—è\n"
                f"   ‚Ä¢ –Æ–∂–Ω–∞—è –ö–æ—Ä–µ—è\n"
                f"   ‚Ä¢ –ò –¥—Ä—É–≥–∏–µ (–æ–±–Ω–æ–≤–ª—è–µ—Ç—Å—è)"
            )
